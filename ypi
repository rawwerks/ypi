#!/bin/bash
# ypi — Y-Combinator Pi — Recursive Coding Agent
#
# Launches Pi as a Recursive Language Model. The LLM gets a system prompt
# that teaches it to use bash + rlm_query for divide-and-conquer reasoning
# over large contexts.
#
# Usage:
#   ypi                              # interactive recursive pi
#   ypi "What is in this repo?"      # one-shot with -p
#   ypi --provider anthropic --model claude-sonnet-4-5-20250929 "question"
#
# Environment overrides:
#   RLM_PROVIDER       — LLM provider for sub-calls (default: Pi's default)
#   RLM_MODEL          — LLM model for sub-calls (default: Pi's default)
#   RLM_MAX_DEPTH      — max recursion depth (default: 3)
#   RLM_TIMEOUT        — wall-clock seconds for entire recursive tree (default: none)
#   RLM_MAX_CALLS      — max total rlm_query invocations (default: none)
#   RLM_CHILD_MODEL    — cheaper model for sub-calls at depth > 0 (default: same as root)
#   RLM_CHILD_PROVIDER — provider for sub-calls at depth > 0 (default: same as root)
#   RLM_JJ             — set to "0" to disable jj workspace isolation (default: 1)
#   RLM_EXTENSIONS     — set to "0" to disable Pi extensions (default: 1)
#   RLM_CHILD_EXTENSIONS — override extensions for depth > 0 (default: same as parent)
#   RLM_BUDGET         — max dollar spend for entire recursive tree (default: none)
#   RLM_JSON           — set to "0" to disable JSON mode / cost tracking (default: 1)
#   RLM_SHARED_SESSIONS — set to "0" to disable session log sharing (default: 1)
#   PI_TRACE_FILE      — path to trace log for all calls with timing (default: none)

set -euo pipefail

# Resolve the directory where ypi lives (and where rlm_query + SYSTEM_PROMPT.md are)
# Follow symlinks — npm install -g creates symlinks in .bin/ pointing to node_modules/ypi/
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"

# Put rlm_query on PATH so Pi's bash tool can find it
export PATH="$SCRIPT_DIR:$PATH"

# Initialize RLM environment — pass through all guardrails
export RLM_DEPTH="${RLM_DEPTH:-0}"
export RLM_MAX_DEPTH="${RLM_MAX_DEPTH:-3}"
[ -n "${RLM_PROVIDER:-}" ]       && export RLM_PROVIDER
[ -n "${RLM_MODEL:-}" ]          && export RLM_MODEL
export RLM_SYSTEM_PROMPT="$SCRIPT_DIR/SYSTEM_PROMPT.md"

# Guardrails — pass through if set, don't override
[ -n "${RLM_TIMEOUT:-}" ]        && export RLM_TIMEOUT
[ -n "${RLM_MAX_CALLS:-}" ]      && export RLM_MAX_CALLS
[ -n "${RLM_CHILD_MODEL:-}" ]    && export RLM_CHILD_MODEL
[ -n "${RLM_CHILD_PROVIDER:-}" ] && export RLM_CHILD_PROVIDER
[ -n "${PI_TRACE_FILE:-}" ]      && export PI_TRACE_FILE
export RLM_JJ="${RLM_JJ:-1}"
export RLM_EXTENSIONS="${RLM_EXTENSIONS:-1}"
[ -n "${RLM_CHILD_EXTENSIONS:-}" ] && export RLM_CHILD_EXTENSIONS
[ -n "${RLM_BUDGET:-}" ]           && export RLM_BUDGET
export RLM_JSON="${RLM_JSON:-1}"
export RLM_SHARED_SESSIONS="${RLM_SHARED_SESSIONS:-1}"

# Session tree tracing — generate a trace ID that links all recursive sessions
export RLM_TRACE_ID="${RLM_TRACE_ID:-$(head -c 4 /dev/urandom | od -An -tx1 | tr -d ' \n')}"

# Compute Pi's session directory for this CWD so children can write there
CWD="$(pwd)"
SAFE_PATH="--$(echo "$CWD" | sed 's|^/||; s|[/:\\]|-|g')--"
export RLM_SESSION_DIR="${HOME}/.pi/agent/sessions/${SAFE_PATH}"
mkdir -p "$RLM_SESSION_DIR"

# Build combined system prompt: SYSTEM_PROMPT.md + rlm_query source
# This way the agent sees the full implementation, not just usage docs.
COMBINED_PROMPT=$(mktemp "${TMPDIR:-/tmp}/ypi_system_prompt.XXXXXX")
trap 'rm -f "$COMBINED_PROMPT"' EXIT

cat "$SCRIPT_DIR/SYSTEM_PROMPT.md" > "$COMBINED_PROMPT"
cat >> "$COMBINED_PROMPT" << 'EOF'

## SECTION 6 – rlm_query Implementation

Below is the full source of `rlm_query`. You are running inside this infrastructure.
Understanding it helps you use recursion effectively and respect guardrails.

```bash
EOF
cat "$SCRIPT_DIR/rlm_query" >> "$COMBINED_PROMPT"
cat >> "$COMBINED_PROMPT" << 'EOF'
```
EOF

# ypi status extension - shows recursive mode indicator in footer
YPI_EXT_ARGS=()
if [ -f "$SCRIPT_DIR/extensions/ypi.ts" ]; then
    YPI_EXT_ARGS=(-e "$SCRIPT_DIR/extensions/ypi.ts")
fi

# Parse --append-system-prompt from args so ypi works like pi with rp
# We append to the combined prompt file rather than passing through,
# since pi already gets --system-prompt from us.
PASS_ARGS=()
QUIET="${YPI_QUIET:-0}"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --append-system-prompt)
            shift
            printf '\n%s\n' "$1" >> "$COMBINED_PROMPT"
            shift
            ;;
        --quiet|-q)
            QUIET=1
            shift
            ;;
        --system-prompt)
            # User overriding ypi's system prompt entirely
            [ "$QUIET" != "1" ] && echo "⚠️  Overriding ypi's system prompt. Did you mean --append-system-prompt?" >&2
            shift
            cat "$1" > "$COMBINED_PROMPT" 2>/dev/null || echo "$1" > "$COMBINED_PROMPT"
            shift
            ;;
        *)
            PASS_ARGS+=("$1")
            shift
            ;;
    esac
done
# Launch Pi with the combined system prompt, passing all args through
# User's own extensions (hashline, etc.) are discovered automatically by Pi.
# Bash 3.2 (macOS) + `set -u` treats `${empty_array[@]}` as unbound.
# Build argv incrementally so zero-length arrays stay zero-arg.
PI_ARGS=(pi --system-prompt "$COMBINED_PROMPT")
if [ ${#YPI_EXT_ARGS[@]} -gt 0 ]; then
    PI_ARGS+=("${YPI_EXT_ARGS[@]}")
fi
if [ ${#PASS_ARGS[@]} -gt 0 ]; then
    PI_ARGS+=("${PASS_ARGS[@]}")
fi
exec "${PI_ARGS[@]}"
