#!/usr/bin/env bash
# rlm_query — Recursive Language Model sub-call for Pi.
#
# This is the Pi/bash equivalent of Python RLM's llm_query().
# Each invocation spawns a child Pi that can answer questions about context.
#
# Usage:
#   rlm_query "Analyze this and extract all dates"
#   echo "some text" | rlm_query "What is the main topic?"
#   sed -n '100,200p' "$CONTEXT" | rlm_query "Summarize this section"
#   rlm_query --fork "Continue working on this refactor"
#
# If stdin has data (piped), that becomes the child's context.
# Otherwise, the child inherits the parent's $CONTEXT file.
#
# Flags:
#   --fork             Fork parent session into child (carries conversation history)
#                      Default: fresh session per child (only data context, no history)
#
# Environment:
#   RLM_DEPTH         — current recursion depth (default: 0)
#   RLM_MAX_DEPTH     — max recursion depth (default: 3)
#   RLM_PROVIDER      — LLM provider
#   RLM_MODEL         — LLM model
#   RLM_SYSTEM_PROMPT — path to the RLM system prompt file
#   CONTEXT           — path to the current context file
#   RLM_STDIN         — set to "1" by the calling pattern to indicate piped input
#   RLM_TIMEOUT       — max wall‑clock seconds for the whole call chain
#   RLM_START_TIME    — epoch seconds when the root call started (auto‑set)
#   RLM_MAX_CALLS     — maximum total rlm_query invocations allowed
#   RLM_CALL_COUNT    — current count of invocations (auto‑incremented)
#   RLM_CHILD_MODEL   — model to use for child calls (depth > 0)
#   RLM_CHILD_PROVIDER— provider to use for child calls (depth > 0)
#   RLM_JJ            — set to "0" to disable jj workspace isolation
#   RLM_TRACE_ID      — shared ID linking all sessions in a recursive tree
#   RLM_SESSION_DIR   — Pi session directory for this project
#   RLM_SESSION_FILE  — parent's session file (used with --fork)

set -euo pipefail

# Structured error helper
rlm_error() { echo "✗ $1" >&2; [ -n "${2:-}" ] && echo "  Why: $2" >&2; [ -n "${3:-}" ] && echo "  Fix: $3" >&2; }

# ----------------------------------------------------------------------
# Parse flags
# ----------------------------------------------------------------------
FORK=false
while [[ "${1:-}" == --* ]]; do
    case "$1" in
        --fork) FORK=true; shift ;;
        *) break ;;
    esac
done

PROMPT="${1:?Usage: rlm_query [--fork] \"your prompt here\"}"

# ----------------------------------------------------------------------
# Depth handling
# ----------------------------------------------------------------------
DEPTH="${RLM_DEPTH:-0}"
MAX_DEPTH="${RLM_MAX_DEPTH:-3}"
NEXT_DEPTH=$((DEPTH + 1))

PROVIDER="${RLM_PROVIDER:-cerebras}"
MODEL="${RLM_MODEL:-gpt-oss-120b}"
SYSTEM_PROMPT_FILE="${RLM_SYSTEM_PROMPT:-}"

# ----------------------------------------------------------------------
# Feature 2 – Timeout start time initialization
# ----------------------------------------------------------------------
if [ -z "${RLM_START_TIME:-}" ]; then
    export RLM_START_TIME=$(date +%s)
fi

# ----------------------------------------------------------------------
# Feature 3 – Call counting & max‑calls guard
# ----------------------------------------------------------------------
RLM_CALL_COUNT=$(( ${RLM_CALL_COUNT:-0} + 1 ))
export RLM_CALL_COUNT
if [ -n "${RLM_MAX_CALLS:-}" ] && [ "$RLM_CALL_COUNT" -ge "$RLM_MAX_CALLS" ]; then
    rlm_error "Max calls exceeded" "$RLM_CALL_COUNT of $RLM_MAX_CALLS calls used" "Increase RLM_MAX_CALLS or reduce recursion depth"
    exit 1
fi

# ----------------------------------------------------------------------
# Session tree — each child gets a persisted session file
# Trace ID groups all sessions from one recursive invocation.
# ----------------------------------------------------------------------
if [ -z "${RLM_TRACE_ID:-}" ]; then
    export RLM_TRACE_ID=$(head -c 4 /dev/urandom | od -An -tx1 | tr -d ' \n')
fi

# Compute child session file path
CHILD_SESSION_FILE=""
if [ -n "${RLM_SESSION_DIR:-}" ]; then
    mkdir -p "$RLM_SESSION_DIR"
    CHILD_SESSION_FILE="${RLM_SESSION_DIR}/${RLM_TRACE_ID}_d${NEXT_DEPTH}_c${RLM_CALL_COUNT}.jsonl"

    # --fork: copy parent session to give child full conversation history
    if [ "$FORK" = true ] && [ -n "${RLM_SESSION_FILE:-}" ] && [ -f "${RLM_SESSION_FILE:-}" ]; then
        cp "$RLM_SESSION_FILE" "$CHILD_SESSION_FILE"
    fi
fi

# ----------------------------------------------------------------------
# Trace logging (optional)
# ----------------------------------------------------------------------
if [ -n "${PI_TRACE_FILE:-}" ]; then
    echo "[$(date +%H:%M:%S.%3N)] depth=$DEPTH→$NEXT_DEPTH PID=$$ PPID=$PPID call=$RLM_CALL_COUNT trace=$RLM_TRACE_ID fork=$FORK prompt: ${PROMPT:0:120}" >> "$PI_TRACE_FILE"
fi

# ----------------------------------------------------------------------
# Temporary child context file
# ----------------------------------------------------------------------
CHILD_CONTEXT=$(mktemp /tmp/rlm_ctx_d${NEXT_DEPTH}_XXXXXX.txt)

# ----------------------------------------------------------------------
# jj workspace isolation — give recursive children their own working copy
# Skipped for leaf nodes (no tools, can't edit files) and when disabled.
# ----------------------------------------------------------------------
JJ_WORKSPACE=""
JJ_WS_NAME=""
if [ "$NEXT_DEPTH" -lt "$MAX_DEPTH" ] \
   && [ "${RLM_JJ:-1}" != "0" ] \
   && command -v jj &>/dev/null \
   && jj root &>/dev/null 2>&1; then
    JJ_WS_NAME="rlm-d${NEXT_DEPTH}-$$"
    JJ_WORKSPACE=$(mktemp -d /tmp/rlm_ws_d${NEXT_DEPTH}_XXXXXX)
    if ! jj workspace add --name "$JJ_WS_NAME" "$JJ_WORKSPACE" &>/dev/null; then
        JJ_WORKSPACE=""
        JJ_WS_NAME=""
    fi
fi

# Cleanup: remove temp context + forget jj workspace
trap '{
    rm -f "$CHILD_CONTEXT"
    if [ -n "$JJ_WS_NAME" ]; then
        jj workspace forget "$JJ_WS_NAME" 2>/dev/null || true
    fi
}' EXIT
trap 'rlm_error "Interrupted" "Received signal" "Re-run the command"; exit 130' INT TERM

# ----------------------------------------------------------------------
# Detect piped stdin
# ----------------------------------------------------------------------
HAS_STDIN=false
if [ -p /dev/stdin ]; then
    HAS_STDIN=true
elif [ -n "${RLM_STDIN:-}" ]; then
    HAS_STDIN=true
fi

if [ "$HAS_STDIN" = true ]; then
    cat > "$CHILD_CONTEXT"
else
    if [ -n "${CONTEXT:-}" ] && [ -f "${CONTEXT:-}" ]; then
        cp "$CONTEXT" "$CHILD_CONTEXT"
    fi
fi

# ----------------------------------------------------------------------
# Feature 4 – Model routing for child calls (depth > 0)
# ----------------------------------------------------------------------
if [ "$DEPTH" -gt 0 ] && [ -n "${RLM_CHILD_MODEL:-}" ]; then
    MODEL="${RLM_CHILD_MODEL}"
    if [ -n "${RLM_CHILD_PROVIDER:-}" ]; then
        PROVIDER="${RLM_CHILD_PROVIDER}"
    fi
fi

# ----------------------------------------------------------------------
# Max‑depth handling (plain LM, no bash tools) — no session (ephemeral)
# ----------------------------------------------------------------------
if [ "$NEXT_DEPTH" -ge "$MAX_DEPTH" ]; then
    CHILD_CONTENT=$(cat "$CHILD_CONTEXT")
    if [ -n "$CHILD_CONTENT" ]; then
        FULL_PROMPT="$PROMPT

Context:
$CHILD_CONTENT"
    else
        FULL_PROMPT="$PROMPT"
    fi

    # Timeout wrapper (Feature 2)
    TIMEOUT_CMD=""
    if [ -n "${RLM_TIMEOUT:-}" ]; then
        ELAPSED=$(( $(date +%s) - RLM_START_TIME ))
        REMAINING=$(( RLM_TIMEOUT - ELAPSED ))
        if [ "$REMAINING" -le 0 ]; then
            rlm_error "Timeout exceeded" "Ran for ${ELAPSED}s of ${RLM_TIMEOUT}s" "Increase RLM_TIMEOUT or simplify the task"
            exit 124
        fi
        TIMEOUT_CMD="timeout $REMAINING"
    fi

    $TIMEOUT_CMD pi -p --provider "$PROVIDER" --model "$MODEL" --no-session --no-extensions --no-tools "$FULL_PROMPT"
    RC=$?
    # Execution summary (Feature 7)
    if [ -n "${PI_TRACE_FILE:-}" ]; then
        ELAPSED=$(( $(date +%s) - RLM_START_TIME ))
        echo "[$(date +%Y-%m-%dT%H:%M:%S%z)] depth=$DEPTH COMPLETED exit=$RC elapsed=${ELAPSED}s" >> "$PI_TRACE_FILE"
    fi
    exit $RC
fi

# ----------------------------------------------------------------------
# Below max depth – spawn recursive child Pi with bash tools + session
# ----------------------------------------------------------------------
export CONTEXT="$CHILD_CONTEXT"
export RLM_DEPTH="$NEXT_DEPTH"
export RLM_MAX_DEPTH="$MAX_DEPTH"
export RLM_PROVIDER="$PROVIDER"
export RLM_MODEL="$MODEL"
export RLM_SYSTEM_PROMPT="${SYSTEM_PROMPT_FILE:-}"
export RLM_START_TIME="${RLM_START_TIME}"
export RLM_TIMEOUT="${RLM_TIMEOUT:-}"
export RLM_TRACE_ID="${RLM_TRACE_ID}"
export RLM_SESSION_DIR="${RLM_SESSION_DIR:-}"

# Pass our session file so children can fork from it
if [ -n "$CHILD_SESSION_FILE" ]; then
    export RLM_SESSION_FILE="$CHILD_SESSION_FILE"
fi

CMD_ARGS=(-p --provider "$PROVIDER" --model "$MODEL" --no-extensions)

# Session: use dedicated file if we have a session dir, otherwise ephemeral
if [ -n "$CHILD_SESSION_FILE" ]; then
    CMD_ARGS+=(--session "$CHILD_SESSION_FILE")
else
    CMD_ARGS+=(--no-session)
fi

if [ -n "$SYSTEM_PROMPT_FILE" ] && [ -f "$SYSTEM_PROMPT_FILE" ]; then
    CMD_ARGS+=(--system-prompt "$SYSTEM_PROMPT_FILE")
fi

# Timeout wrapper for recursive pi call (Feature 2)
TIMEOUT_CMD=""
if [ -n "${RLM_TIMEOUT:-}" ]; then
    ELAPSED=$(( $(date +%s) - RLM_START_TIME ))
    REMAINING=$(( RLM_TIMEOUT - ELAPSED ))
    if [ "$REMAINING" -le 0 ]; then
        rlm_error "Timeout exceeded" "Ran for ${ELAPSED}s of ${RLM_TIMEOUT}s" "Increase RLM_TIMEOUT or simplify the task"
        exit 124
    fi
    TIMEOUT_CMD="timeout $REMAINING"
fi

# Enter jj workspace if available (child gets isolated working copy)
if [ -n "$JJ_WORKSPACE" ]; then
    cd "$JJ_WORKSPACE"
fi

$TIMEOUT_CMD pi "${CMD_ARGS[@]}" "$PROMPT"
RC=$?
# Execution summary (Feature 7)
if [ -n "${PI_TRACE_FILE:-}" ]; then
    ELAPSED=$(( $(date +%s) - RLM_START_TIME ))
    echo "[$(date +%Y-%m-%dT%H:%M:%S%z)] depth=$DEPTH COMPLETED exit=$RC elapsed=${ELAPSED}s" >> "$PI_TRACE_FILE"
fi
exit $RC
