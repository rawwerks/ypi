#!/usr/bin/env bash
# rlm_query — Recursive Language Model sub-call for Pi.
#
# This is the Pi/bash equivalent of Python RLM's llm_query().
# Each invocation spawns a child Pi that can answer questions about context.
#
# Usage:
#   rlm_query "Analyze this and extract all dates"
#   echo "some text" | rlm_query "What is the main topic?"
#   sed -n '100,200p' "$CONTEXT" | rlm_query "Summarize this section"
#   rlm_query --fork "Continue working on this refactor"
#   rlm_query --async "Analyze the codebase"   # returns immediately with job JSON
#   echo "data" | rlm_query --async --notify $$ "Summarize this"
#
# If stdin has data (piped), that becomes the child's context.
# Otherwise, the child inherits the parent's $CONTEXT file.
#
# Flags:
#   --fork             Fork parent session into child (carries conversation history)
#                      Default: fresh session per child (only data context, no history)
#   --async            Spawn child in background, return immediately with job JSON
#                      Output goes to a temp file; sentinel touched when done
#   --notify PID       With --async: write result to target PID's peer inbox when done
#
# Environment:
#   RLM_DEPTH         — current recursion depth (default: 0)
#   RLM_MAX_DEPTH     — max recursion depth (default: 3)
#   RLM_PROVIDER      — LLM provider
#   RLM_MODEL         — LLM model
#   RLM_SYSTEM_PROMPT — path to the RLM system prompt file
#   CONTEXT           — path to the current context file
#   RLM_STDIN         — set to "1" by the calling pattern to indicate piped input
#   RLM_TIMEOUT       — max wall‑clock seconds for the whole call chain
#   RLM_START_TIME    — epoch seconds when the root call started (auto‑set)
#   RLM_MAX_CALLS     — maximum total rlm_query invocations allowed
#   RLM_CALL_COUNT    — current count of invocations (auto‑incremented)
#   RLM_CHILD_MODEL   — model to use for child calls (depth > 0)
#   RLM_CHILD_PROVIDER— provider to use for child calls (depth > 0)
#   RLM_JJ            — set to "0" to disable jj workspace isolation
#   RLM_EXTENSIONS    — set to "0" to disable Pi extensions (default: 1)
#   RLM_CHILD_EXTENSIONS — override extensions for depth > 0 (default: same as parent)
#   RLM_BUDGET        — max dollar spend for entire recursive tree (e.g. "0.50")
#   RLM_COST_FILE     — shared file tracking cumulative cost (auto‑created)
#   RLM_JSON          — set to "0" to disable JSON mode (plain text, no cost tracking)
#   RLM_TRACE_ID      — shared ID linking all sessions in a recursive tree
#   RLM_SESSION_DIR   — Pi session directory for this project
#   RLM_SESSION_FILE  — parent's session file (used with --fork)

set -euo pipefail

# Structured error helper
rlm_error() { echo "✗ $1" >&2; [ -n "${2:-}" ] && echo "  Why: $2" >&2; [ -n "${3:-}" ] && echo "  Fix: $3" >&2; }

# ----------------------------------------------------------------------
# Parse flags
# ----------------------------------------------------------------------
FORK=false
ASYNC=false
NOTIFY_PID=""
while [[ "${1:-}" == --* ]]; do
    case "$1" in
        --fork) FORK=true; shift ;;
        --async) ASYNC=true; shift ;;
        --notify) NOTIFY_PID="$2"; shift 2 ;;
        *) break ;;
    esac
done

PROMPT="${1:?Usage: rlm_query [--fork] [--async] [--notify PID] \"your prompt here\"}"

# ----------------------------------------------------------------------
# Depth guard — refuse to go beyond max depth
# This is the only recursion limiter. Children get full tools/extensions.
# ----------------------------------------------------------------------
DEPTH="${RLM_DEPTH:-0}"
MAX_DEPTH="${RLM_MAX_DEPTH:-3}"
NEXT_DEPTH=$((DEPTH + 1))

if [ "$NEXT_DEPTH" -gt "$MAX_DEPTH" ]; then
    rlm_error "Max depth exceeded" "At depth $DEPTH of $MAX_DEPTH" "Increase RLM_MAX_DEPTH or simplify the task"
    exit 1
fi

# ----------------------------------------------------------------------
# Stale temp reaper — runs once per root invocation (depth 0 only)
# Cleans up leaked files from crashed/killed processes (SIGKILL skips traps)
# ----------------------------------------------------------------------
if [ "$DEPTH" -eq 0 ]; then
    (
        # Delete rlm temp files older than 2 hours whose parent process is gone
        find /tmp -maxdepth 1 -name 'rlm_*' -mmin +120 -delete 2>/dev/null
        # Remove stale jj workspace directories older than 2 hours
        find /tmp -maxdepth 1 -name 'rlm_ws_*' -type d -mmin +120 -exec rm -rf {} + 2>/dev/null
    ) &
fi

PROVIDER="${RLM_PROVIDER:-}"
MODEL="${RLM_MODEL:-}"
SYSTEM_PROMPT_FILE="${RLM_SYSTEM_PROMPT:-}"

# ----------------------------------------------------------------------
# Timeout start time initialization
# ----------------------------------------------------------------------
if [ -z "${RLM_START_TIME:-}" ]; then
    export RLM_START_TIME=$(date +%s)
fi

# ----------------------------------------------------------------------
# Call counting & max‑calls guard
# ----------------------------------------------------------------------
RLM_CALL_COUNT=$(( ${RLM_CALL_COUNT:-0} + 1 ))
export RLM_CALL_COUNT
if [ -n "${RLM_MAX_CALLS:-}" ] && [ "$RLM_CALL_COUNT" -ge "$RLM_MAX_CALLS" ]; then
    rlm_error "Max calls exceeded" "$RLM_CALL_COUNT of $RLM_MAX_CALLS calls used" "Increase RLM_MAX_CALLS or reduce recursion depth"
    exit 1
fi

# ----------------------------------------------------------------------
# Budget guard — check cumulative cost before proceeding
# ----------------------------------------------------------------------
if [ -n "${RLM_BUDGET:-}" ] && [ -n "${RLM_COST_FILE:-}" ] && [ -f "$RLM_COST_FILE" ]; then
    CURRENT_COST=$(python3 -c "
import json
total = 0.0
with open('$RLM_COST_FILE') as f:
    for line in f:
        line = line.strip()
        if line:
            try: total += json.loads(line).get('cost', 0)
            except: pass
print(f'{total:.6f}')
" 2>/dev/null || echo "0")
    OVER=$(python3 -c "print('yes' if $CURRENT_COST >= $RLM_BUDGET else 'no')" 2>/dev/null || echo "no")
    if [ "$OVER" = "yes" ]; then
        rlm_error "Budget exceeded" "Spent \$$CURRENT_COST of \$$RLM_BUDGET budget" "Increase RLM_BUDGET or simplify the task"
        exit 1
    fi
fi

# Initialize cost file if budget is set but no file exists yet
if [ -n "${RLM_BUDGET:-}" ] && [ -z "${RLM_COST_FILE:-}" ]; then
    export RLM_COST_FILE=$(mktemp /tmp/rlm_cost_XXXXXX.jsonl)
fi

# ----------------------------------------------------------------------
# Session tree — each child gets a persisted session file
# Trace ID groups all sessions from one recursive invocation.
# ----------------------------------------------------------------------
if [ -z "${RLM_TRACE_ID:-}" ]; then
    export RLM_TRACE_ID=$(head -c 4 /dev/urandom | od -An -tx1 | tr -d ' \n')
fi

CHILD_SESSION_FILE=""
if [ -n "${RLM_SESSION_DIR:-}" ]; then
    mkdir -p "$RLM_SESSION_DIR"
    CHILD_SESSION_FILE="${RLM_SESSION_DIR}/${RLM_TRACE_ID}_d${NEXT_DEPTH}_c${RLM_CALL_COUNT}.jsonl"

    # --fork: copy parent session to give child full conversation history
    if [ "$FORK" = true ] && [ -n "${RLM_SESSION_FILE:-}" ] && [ -f "${RLM_SESSION_FILE:-}" ]; then
        cp "$RLM_SESSION_FILE" "$CHILD_SESSION_FILE"
    fi
fi

# ----------------------------------------------------------------------
# Trace logging (optional)
# ----------------------------------------------------------------------
if [ -n "${PI_TRACE_FILE:-}" ]; then
    echo "[$(date +%H:%M:%S.%3N)] depth=$DEPTH→$NEXT_DEPTH PID=$$ PPID=$PPID call=$RLM_CALL_COUNT trace=$RLM_TRACE_ID fork=$FORK prompt: ${PROMPT:0:120}" >> "$PI_TRACE_FILE"
fi

# ----------------------------------------------------------------------
# Temporary child context file
# ----------------------------------------------------------------------
CHILD_CONTEXT=$(mktemp /tmp/rlm_ctx_d${NEXT_DEPTH}_XXXXXX.txt)
COMBINED_PROMPT=""

# Write prompt to a file for symbolic access — agents can grep/sed the original
# question instead of relying on in-context token copying.
PROMPT_FILE=$(mktemp /tmp/rlm_prompt_d${NEXT_DEPTH}_XXXXXX.txt)
echo "$PROMPT" > "$PROMPT_FILE"

# ----------------------------------------------------------------------
# jj workspace isolation — give recursive children their own working copy
# ----------------------------------------------------------------------
JJ_WORKSPACE=""
JJ_WS_NAME=""
if [ "${RLM_JJ:-1}" != "0" ] \
   && command -v jj &>/dev/null \
   && jj root &>/dev/null 2>&1; then
    JJ_WS_NAME="rlm-d${NEXT_DEPTH}-$$"
    JJ_WORKSPACE=$(mktemp -d /tmp/rlm_ws_d${NEXT_DEPTH}_XXXXXX)
    if ! jj workspace add --name "$JJ_WS_NAME" "$JJ_WORKSPACE" &>/dev/null; then
        JJ_WORKSPACE=""
        JJ_WS_NAME=""
    fi
fi

# Cleanup: remove temp context + forget jj workspace (updated in run section below)
# In async mode, the child needs these files — skip cleanup (child cleans up after itself)
if [ "$ASYNC" != true ]; then
trap '{
    rm -f "$CHILD_CONTEXT" "$PROMPT_FILE"
    rm -f "${COMBINED_PROMPT:-}"
    if [ -n "$JJ_WS_NAME" ]; then
        jj workspace forget "$JJ_WS_NAME" 2>/dev/null || true
    fi
}' EXIT
fi
trap 'rlm_error "Interrupted" "Received signal" "Re-run the command"; exit 130' INT TERM

# ----------------------------------------------------------------------
# Detect piped stdin
# ----------------------------------------------------------------------
HAS_STDIN=false
if [ -p /dev/stdin ]; then
    HAS_STDIN=true
elif [ -n "${RLM_STDIN:-}" ]; then
    HAS_STDIN=true
fi

if [ "$HAS_STDIN" = true ]; then
    cat > "$CHILD_CONTEXT"
else
    if [ -n "${CONTEXT:-}" ] && [ -f "${CONTEXT:-}" ]; then
        cp "$CONTEXT" "$CHILD_CONTEXT"
    fi
fi

# ----------------------------------------------------------------------
# Model routing for child calls (depth > 0)
# ----------------------------------------------------------------------
if [ "$DEPTH" -gt 0 ] && [ -n "${RLM_CHILD_MODEL:-}" ]; then
    MODEL="${RLM_CHILD_MODEL}"
    if [ -n "${RLM_CHILD_PROVIDER:-}" ]; then
        PROVIDER="${RLM_CHILD_PROVIDER}"
    fi
fi

# ----------------------------------------------------------------------
# Spawn child Pi with tools, extensions, and session
# ----------------------------------------------------------------------
export CONTEXT="$CHILD_CONTEXT"
export RLM_PROMPT_FILE="$PROMPT_FILE"
export RLM_DEPTH="$NEXT_DEPTH"
export RLM_MAX_DEPTH="$MAX_DEPTH"
export RLM_PROVIDER="$PROVIDER"
export RLM_MODEL="$MODEL"
export RLM_SYSTEM_PROMPT="${SYSTEM_PROMPT_FILE:-}"
export RLM_START_TIME="${RLM_START_TIME}"
export RLM_TIMEOUT="${RLM_TIMEOUT:-}"
export RLM_TRACE_ID="${RLM_TRACE_ID}"
export RLM_SESSION_DIR="${RLM_SESSION_DIR:-}"
export RLM_BUDGET="${RLM_BUDGET:-}"
export RLM_COST_FILE="${RLM_COST_FILE:-}"
export RLM_SHARED_SESSIONS="${RLM_SHARED_SESSIONS:-1}"

# At max depth: remove rlm_query from PATH so the child can't recurse.
# The child still gets full tools (bash, read, write, edit) — it just
# can't spawn sub-agents. The depth guard above is a safety net.
# Follow symlinks — npm install -g creates symlinks in .bin/
SCRIPT_DIR="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)"
if [ "$NEXT_DEPTH" -ge "$MAX_DEPTH" ]; then
    export PATH=$(echo "$PATH" | tr ':' '\n' | grep -v "^${SCRIPT_DIR}$" | paste -sd ':' -)
fi

if [ -n "$CHILD_SESSION_FILE" ]; then
    export RLM_SESSION_FILE="$CHILD_SESSION_FILE"
fi

CMD_ARGS=(-p)
[ -n "$PROVIDER" ] && CMD_ARGS+=(--provider "$PROVIDER")
[ -n "$MODEL" ] && CMD_ARGS+=(--model "$MODEL")

# Extensions: on by default, configurable per-instance like model routing
CHILD_EXT="${RLM_EXTENSIONS:-1}"
if [ "$DEPTH" -gt 0 ] && [ -n "${RLM_CHILD_EXTENSIONS:-}" ]; then
    CHILD_EXT="${RLM_CHILD_EXTENSIONS}"
fi
if [ "$CHILD_EXT" = "0" ]; then
    CMD_ARGS+=(--no-extensions)
fi

# Session: use dedicated file if we have a session dir, otherwise ephemeral
if [ -n "$CHILD_SESSION_FILE" ]; then
    CMD_ARGS+=(--session "$CHILD_SESSION_FILE")
else
    CMD_ARGS+=(--no-session)
fi

# Build combined system prompt with rlm_query source embedded
COMBINED_PROMPT=""
if [ -n "$SYSTEM_PROMPT_FILE" ] && [ -f "$SYSTEM_PROMPT_FILE" ]; then
    COMBINED_PROMPT=$(mktemp /tmp/rlm_system_prompt_XXXXXX.md)
    cat "$SYSTEM_PROMPT_FILE" > "$COMBINED_PROMPT"
    SELF_SOURCE="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)/rlm_query"
    if [ -f "$SELF_SOURCE" ]; then
        cat >> "$COMBINED_PROMPT" << 'SYSEOF'

## SECTION 6 – rlm_query Implementation

Below is the full source of `rlm_query`. You are running inside this infrastructure.
Understanding it helps you use recursion effectively and respect guardrails.

```bash
SYSEOF
        cat "$SELF_SOURCE" >> "$COMBINED_PROMPT"
        echo '```' >> "$COMBINED_PROMPT"
    fi
    CMD_ARGS+=(--system-prompt "$COMBINED_PROMPT")
fi

# Timeout wrapper
TIMEOUT_CMD=""
if [ -n "${RLM_TIMEOUT:-}" ]; then
    ELAPSED=$(( $(date +%s) - RLM_START_TIME ))
    REMAINING=$(( RLM_TIMEOUT - ELAPSED ))
    if [ "$REMAINING" -le 0 ]; then
        rlm_error "Timeout exceeded" "Ran for ${ELAPSED}s of ${RLM_TIMEOUT}s" "Increase RLM_TIMEOUT or simplify the task"
        exit 124
    fi
    TIMEOUT_CMD="timeout $REMAINING"
fi

# Enter jj workspace if available (child gets isolated working copy)
if [ -n "$JJ_WORKSPACE" ]; then
    cd "$JJ_WORKSPACE"
fi

# ----------------------------------------------------------------------
# Async mode — spawn child in background and return immediately
# ----------------------------------------------------------------------
if [ "$ASYNC" = true ]; then
    ASYNC_ID="rlm_async_${RLM_TRACE_ID}_c${RLM_CALL_COUNT}_$(head -c 4 /dev/urandom | od -An -tx1 | tr -d ' \n')"
    ASYNC_OUTPUT="/tmp/${ASYNC_ID}.txt"
    ASYNC_SENTINEL="/tmp/${ASYNC_ID}.done"

    # Build the full command
    CHILD_CMD=(pi "${CMD_ARGS[@]}" "$PROMPT")
    if [ -n "$TIMEOUT_CMD" ]; then
        CHILD_CMD=($TIMEOUT_CMD "${CHILD_CMD[@]}")
    fi

    # Spawn in background: run child, capture output, touch sentinel, optionally notify
    (
        "${CHILD_CMD[@]}" > "$ASYNC_OUTPUT" 2>&1
        touch "$ASYNC_SENTINEL"

        # If --notify PID was given, write to that peer's inbox
        if [ -n "$NOTIFY_PID" ]; then
            INBOX_DIR=$(find /tmp/pi_peer_* -maxdepth 0 -type d 2>/dev/null | while read d; do
                if [ -f "$d/meta.json" ] && grep -q "\"pid\":$NOTIFY_PID" "$d/meta.json" 2>/dev/null; then
                    echo "$d"; break
                fi
            done)
            if [ -n "$INBOX_DIR" ] && [ -d "$INBOX_DIR" ]; then
                RESULT=$(cat "$ASYNC_OUTPUT" | tail -c 50000)
                MSG=$(cat <<MSGJSON
{"from_pid":$$,"from_project":"rlm_query","message":"[rlm_query --async result]\n\n$RESULT","timestamp":"$(date -Iseconds)","id":"async_${ASYNC_ID}"}
MSGJSON
)
                echo "$MSG" >> "$INBOX_DIR/inbox.jsonl"
            fi
        fi

        # Clean up temp files the parent skipped
        rm -f "$CHILD_CONTEXT" "$PROMPT_FILE" "${COMBINED_PROMPT:-}"
        if [ -n "$JJ_WS_NAME" ]; then
            jj workspace forget "$JJ_WS_NAME" 2>/dev/null || true
        fi
    ) &
    ASYNC_PID=$!
    disown $ASYNC_PID 2>/dev/null || true

    # Return job metadata immediately
    cat <<EOF
{"job_id": "$ASYNC_ID", "output": "$ASYNC_OUTPUT", "sentinel": "$ASYNC_SENTINEL", "pid": $ASYNC_PID}
EOF
    exit 0
fi

# ----------------------------------------------------------------------
# Run child Pi — JSON mode (default) or plain text
# JSON mode streams text to stdout and captures cost via fd 3.
# ----------------------------------------------------------------------
COST_OUT=$(mktemp /tmp/rlm_cost_out_XXXXXX.json)
trap '{
    rm -f "$CHILD_CONTEXT" "$PROMPT_FILE"
    rm -f "${COMBINED_PROMPT:-}"
    rm -f "$COST_OUT"
    if [ -n "$JJ_WS_NAME" ]; then
        jj workspace forget "$JJ_WS_NAME" 2>/dev/null || true
    fi
}' EXIT

if [ "${RLM_JSON:-1}" != "0" ]; then
    # JSON mode: get structured cost + stream text
    # Replace -p with --mode json, pipe through parser
    JSON_CMD_ARGS=()
    for arg in "${CMD_ARGS[@]}"; do
        [ "$arg" = "-p" ] && continue
        JSON_CMD_ARGS+=("$arg")
    done
    JSON_CMD_ARGS+=(--mode json)

    PARSER="$(cd "$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")" && pwd)/rlm_parse_json"

    $TIMEOUT_CMD pi "${JSON_CMD_ARGS[@]}" "$PROMPT" 2>/dev/null | python3 "$PARSER" 3>"$COST_OUT"
    RC=${PIPESTATUS[0]}

    # Record cost if we got data
    if [ -s "$COST_OUT" ] && [ -n "${RLM_COST_FILE:-}" ]; then
        cat "$COST_OUT" >> "$RLM_COST_FILE"
    fi

    # Log cost to trace
    if [ -s "$COST_OUT" ] && [ -n "${PI_TRACE_FILE:-}" ]; then
        COST_DATA=$(cat "$COST_OUT")
        ELAPSED=$(( $(date +%s) - RLM_START_TIME ))
        echo "[$(date +%Y-%m-%dT%H:%M:%S%z)] depth=$DEPTH COMPLETED exit=$RC elapsed=${ELAPSED}s cost=$COST_DATA" >> "$PI_TRACE_FILE"
    elif [ -n "${PI_TRACE_FILE:-}" ]; then
        ELAPSED=$(( $(date +%s) - RLM_START_TIME ))
        echo "[$(date +%Y-%m-%dT%H:%M:%S%z)] depth=$DEPTH COMPLETED exit=$RC elapsed=${ELAPSED}s" >> "$PI_TRACE_FILE"
    fi
else
    # Plain text mode (RLM_JSON=0): no cost tracking
    $TIMEOUT_CMD pi "${CMD_ARGS[@]}" "$PROMPT"
    RC=$?

    if [ -n "${PI_TRACE_FILE:-}" ]; then
        ELAPSED=$(( $(date +%s) - RLM_START_TIME ))
        echo "[$(date +%Y-%m-%dT%H:%M:%S%z)] depth=$DEPTH COMPLETED exit=$RC elapsed=${ELAPSED}s" >> "$PI_TRACE_FILE"
    fi
fi

exit $RC
